{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/austin/Desktop/bbgo/frontend/node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _s = $RefreshSig$();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useIntersection = useIntersection;\n\nvar _react = require(\"react\");\n\nvar _requestIdleCallback = require(\"./request-idle-callback\");\n\nvar hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';\n\nfunction useIntersection(_ref) {\n  _s();\n\n  var rootMargin = _ref.rootMargin,\n      disabled = _ref.disabled;\n  var isDisabled = disabled || !hasIntersectionObserver;\n  var unobserve = (0, _react).useRef();\n\n  var _useState = (0, _react).useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      visible = _useState2[0],\n      setVisible = _useState2[1];\n\n  var setRef = (0, _react).useCallback(function (el) {\n    if (unobserve.current) {\n      unobserve.current();\n      unobserve.current = undefined;\n    }\n\n    if (isDisabled || visible) return;\n\n    if (el && el.tagName) {\n      unobserve.current = observe(el, function (isVisible) {\n        return isVisible && setVisible(isVisible);\n      }, {\n        rootMargin: rootMargin\n      });\n    }\n  }, [isDisabled, rootMargin, visible]);\n  (0, _react).useEffect(function () {\n    if (!hasIntersectionObserver) {\n      if (!visible) {\n        var idleCallback = (0, _requestIdleCallback).requestIdleCallback(function () {\n          return setVisible(true);\n        });\n        return function () {\n          return (0, _requestIdleCallback).cancelIdleCallback(idleCallback);\n        };\n      }\n    }\n  }, [visible]);\n  return [setRef, visible];\n}\n\n_s(useIntersection, \"Z6jj7qx+KE6gD9CpC9WlQTha45o=\");\n\nfunction observe(element, callback, options) {\n  var _createObserver = createObserver(options),\n      id = _createObserver.id,\n      observer = _createObserver.observer,\n      elements = _createObserver.elements;\n\n  elements.set(element, callback);\n  observer.observe(element);\n  return function unobserve() {\n    elements[\"delete\"](element);\n    observer.unobserve(element); // Destroy observer when there's nothing left to watch:\n\n    if (elements.size === 0) {\n      observer.disconnect();\n      observers[\"delete\"](id);\n    }\n  };\n}\n\nvar observers = new Map();\n\nfunction createObserver(options) {\n  var id = options.rootMargin || '';\n  var instance = observers.get(id);\n\n  if (instance) {\n    return instance;\n  }\n\n  var elements = new Map();\n  var observer = new IntersectionObserver(function (entries) {\n    entries.forEach(function (entry) {\n      var callback = elements.get(entry.target);\n      var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n\n      if (callback && isVisible) {\n        callback(isVisible);\n      }\n    });\n  }, options);\n  observers.set(id, instance = {\n    id: id,\n    observer: observer,\n    elements: elements\n  });\n  return instance;\n}","map":{"version":3,"sources":["../../client/use-intersection.tsx"],"names":[],"mappings":"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","sourcesContent":["import { useCallback, useEffect, useRef, useState } from 'react'\nimport {\n  requestIdleCallback,\n  cancelIdleCallback,\n} from './request-idle-callback'\n\ntype UseIntersectionObserverInit = Pick<IntersectionObserverInit, 'rootMargin'>\ntype UseIntersection = { disabled?: boolean } & UseIntersectionObserverInit\ntype ObserveCallback = (isVisible: boolean) => void\ntype Observer = {\n  id: string\n  observer: IntersectionObserver\n  elements: Map<Element, ObserveCallback>\n}\n\nconst hasIntersectionObserver = typeof IntersectionObserver !== 'undefined'\n\nexport function useIntersection<T extends Element>({\n  rootMargin,\n  disabled,\n}: UseIntersection): [(element: T | null) => void, boolean] {\n  const isDisabled: boolean = disabled || !hasIntersectionObserver\n\n  const unobserve = useRef<Function>()\n  const [visible, setVisible] = useState(false)\n\n  const setRef = useCallback(\n    (el: T | null) => {\n      if (unobserve.current) {\n        unobserve.current()\n        unobserve.current = undefined\n      }\n\n      if (isDisabled || visible) return\n\n      if (el && el.tagName) {\n        unobserve.current = observe(\n          el,\n          (isVisible) => isVisible && setVisible(isVisible),\n          { rootMargin }\n        )\n      }\n    },\n    [isDisabled, rootMargin, visible]\n  )\n\n  useEffect(() => {\n    if (!hasIntersectionObserver) {\n      if (!visible) {\n        const idleCallback = requestIdleCallback(() => setVisible(true))\n        return () => cancelIdleCallback(idleCallback)\n      }\n    }\n  }, [visible])\n\n  return [setRef, visible]\n}\n\nfunction observe(\n  element: Element,\n  callback: ObserveCallback,\n  options: UseIntersectionObserverInit\n): () => void {\n  const { id, observer, elements } = createObserver(options)\n  elements.set(element, callback)\n\n  observer.observe(element)\n  return function unobserve(): void {\n    elements.delete(element)\n    observer.unobserve(element)\n\n    // Destroy observer when there's nothing left to watch:\n    if (elements.size === 0) {\n      observer.disconnect()\n      observers.delete(id)\n    }\n  }\n}\n\nconst observers = new Map<string, Observer>()\nfunction createObserver(options: UseIntersectionObserverInit): Observer {\n  const id = options.rootMargin || ''\n  let instance = observers.get(id)\n  if (instance) {\n    return instance\n  }\n\n  const elements = new Map<Element, ObserveCallback>()\n  const observer = new IntersectionObserver((entries) => {\n    entries.forEach((entry) => {\n      const callback = elements.get(entry.target)\n      const isVisible = entry.isIntersecting || entry.intersectionRatio > 0\n      if (callback && isVisible) {\n        callback(isVisible)\n      }\n    })\n  }, options)\n\n  observers.set(\n    id,\n    (instance = {\n      id,\n      observer,\n      elements,\n    })\n  )\n  return instance\n}\n"]},"metadata":{},"sourceType":"script"}