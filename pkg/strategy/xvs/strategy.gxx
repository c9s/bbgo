package xvs

import (
	"context"
	"fmt"
	"sync"

	"github.com/sirupsen/logrus"

	"github.com/c9s/bbgo/pkg/bbgo"
	"github.com/c9s/bbgo/pkg/fixedpoint"
	"github.com/c9s/bbgo/pkg/indicator"
	"github.com/c9s/bbgo/pkg/strategy/common"
	"github.com/c9s/bbgo/pkg/types"
)

const ID = "xvs"

var log = logrus.WithField("strategy", ID)

func init() {
	bbgo.RegisterStrategy(ID, &Strategy{})
}

type Strategy struct {
	*common.Strategy

	Symbol string       `json:"symbol"`
	Market types.Market `json:"-"`

	// Entry conditions
	VolumeInterval         types.Interval   `json:"volumeInterval"`         // 5m or 15m
	VolumeThreshold        fixedpoint.Value `json:"volumeThreshold"`        // >= 800 BTC
	VolumeThresholdInQuote fixedpoint.Value `json:"volumeThresholdInQuote"` // > 40M USDT
	MinKLineShadowRatio    fixedpoint.Value `json:"minKLineShadowRatio"`    // 0.1 means 90% down body

	// EMA settings
	EMA120d types.IntervalWindow `json:"ema120d"` // 120d EMA for entry filter

	// Exit conditions
	EngulfingInterval types.Interval `json:"engulfingInterval"` // 30m

	// Order settings
	Quantity              fixedpoint.Value                `json:"quantity"`
	MarginOrderSideEffect types.MarginOrderSideEffectType `json:"marginOrderSideEffect"`

	// Exit methods
	ExitMethods bbgo.ExitMethodSet `json:"exits"`

	orderExecutor *bbgo.GeneralOrderExecutor

	// Indicators
	ema120d *indicator.EWMA

	// Kline tracking for engulfing pattern
	lastGreenKline *types.KLine

	// Position and stats
	Position    *types.Position    `persistence:"position"`
	ProfitStats *types.ProfitStats `persistence:"profit_stats"`
	TradeStats  *types.TradeStats  `persistence:"trade_stats"`

	// StrategyController
	bbgo.StrategyController
}

func (s *Strategy) ID() string {
	return ID
}

func (s *Strategy) InstanceID() string {
	return fmt.Sprintf("%s:%s", ID, s.Symbol)
}

func (s *Strategy) Validate() error {
	if s.Quantity.IsZero() {
		return fmt.Errorf("quantity can not be zero")
	}
	if s.VolumeThreshold.IsZero() && s.VolumeThresholdInQuote.IsZero() {
		return fmt.Errorf("either volumeThreshold or volumeThresholdInQuote must be set")
	}
	return nil
}

func (s *Strategy) Defaults() error {
	if s.VolumeInterval == "" {
		s.VolumeInterval = types.Interval5m
	}
	if s.EngulfingInterval == "" {
		s.EngulfingInterval = types.Interval30m
	}
	if s.MinKLineShadowRatio.IsZero() {
		s.MinKLineShadowRatio = fixedpoint.NewFromFloat(0.1) // 90% down body
	}
	if s.EMA120d == (types.IntervalWindow{}) {
		s.EMA120d = types.IntervalWindow{
			Interval: types.Interval1d,
			Window:   120,
		}
	}
	return nil
}

func (s *Strategy) Subscribe(session *bbgo.ExchangeSession) {
	// Subscribe to volume interval for entry signals
	session.Subscribe(types.KLineChannel, s.Symbol, types.SubscribeOptions{Interval: s.VolumeInterval})

	// Subscribe to engulfing interval for exit signals
	session.Subscribe(types.KLineChannel, s.Symbol, types.SubscribeOptions{Interval: s.EngulfingInterval})

	// Subscribe to EMA intervals
	session.Subscribe(types.KLineChannel, s.Symbol, types.SubscribeOptions{Interval: s.EMA120d.Interval})

	// Subscribe exit methods
	s.ExitMethods.Subscribe(session, s.Symbol)
}

func (s *Strategy) CurrentPosition() *types.Position {
	return s.Position
}

func (s *Strategy) ClosePosition(ctx context.Context, percentage fixedpoint.Value) error {
	base := s.Position.GetBase()
	if base.IsZero() {
		return fmt.Errorf("no opened %s position", s.Position.Symbol)
	}

	quantity := base.Mul(percentage).Abs()
	side := types.SideTypeBuy
	if base.Sign() > 0 {
		side = types.SideTypeSell
	}

	if quantity.Compare(s.Market.MinQuantity) < 0 {
		return fmt.Errorf("order quantity %v is too small, less than %v", quantity, s.Market.MinQuantity)
	}

	submitOrder := types.SubmitOrder{
		Symbol:   s.Symbol,
		Side:     side,
		Type:     types.OrderTypeMarket,
		Quantity: quantity,
		Market:   s.Market,
	}

	bbgo.Notify("Submitting %s %s order to close position by %v", s.Symbol, side.String(), percentage, submitOrder)
	_, err := s.orderExecutor.SubmitOrders(ctx, submitOrder)
	return err
}

func (s *Strategy) checkVolumeBreakout(kline types.KLine) bool {
	// Check volume threshold
	if !s.VolumeThreshold.IsZero() && kline.Volume.Compare(s.VolumeThreshold) < 0 {
		return false
	}

	if !s.VolumeThresholdInQuote.IsZero() && kline.QuoteVolume.Compare(s.VolumeThresholdInQuote) < 0 {
		return false
	}

	// Check if kline is not 90% down (not full body black)
	bodySize := kline.GetClose().Sub(kline.GetOpen()).Abs()
	totalSize := kline.GetHigh().Sub(kline.GetLow())

	if totalSize.IsZero() {
		return false
	}

	shadowRatio := fixedpoint.One.Sub(bodySize.Div(totalSize))
	if shadowRatio.Compare(s.MinKLineShadowRatio) < 0 {
		log.Infof("Kline has too small shadow ratio %s, required >= %s", shadowRatio, s.MinKLineShadowRatio)
		return false
	}

	return true
}

func (s *Strategy) checkEMAFilter(closePrice fixedpoint.Value) bool {
	if s.ema120d == nil {
		return true
	}

	emaValue := fixedpoint.NewFromFloat(s.ema120d.Last(0))
	// Skip entry if price closed from above 120d EMA to below
	if closePrice.Compare(emaValue) < 0 {
		log.Infof("Price %s is below 120d EMA %s, skipping entry", closePrice, emaValue)
		return false
	}

	return true
}

func (s *Strategy) checkEngulfingExit(kline types.KLine) bool {
	if s.lastGreenKline == nil {
		return false
	}

	// Current kline must be red and closed lower than previous green bar's open
	if kline.GetClose().Compare(kline.GetOpen()) >= 0 {
		return false // Not red
	}

	if kline.GetClose().Compare(s.lastGreenKline.GetOpen()) >= 0 {
		return false // Not lower than previous green open
	}

	// Volume must be greater than previous green bar
	if kline.Volume.Compare(s.lastGreenKline.Volume) <= 0 {
		return false
	}

	return true
}

func (s *Strategy) Run(ctx context.Context, orderExecutor bbgo.OrderExecutor, session *bbgo.ExchangeSession) error {
	instanceID := s.InstanceID()

	if s.Position == nil {
		s.Position = types.NewPositionFromMarket(s.Market)
	}

	if s.ProfitStats == nil {
		s.ProfitStats = types.NewProfitStats(s.Market)
	}

	if s.TradeStats == nil {
		s.TradeStats = types.NewTradeStats(s.Symbol)
	}

	s.orderExecutor = bbgo.NewGeneralOrderExecutor(session, s.Symbol, ID, instanceID, s.Position)
	s.orderExecutor.BindEnvironment(s.Environment)
	s.orderExecutor.BindProfitStats(s.ProfitStats)
	s.orderExecutor.BindTradeStats(s.TradeStats)
	s.orderExecutor.Bind()

	// Setup exit methods
	s.ExitMethods.Bind(session, s.orderExecutor)

	// StrategyController
	s.Status = types.StrategyStatusRunning

	s.OnSuspend(func() {
		_ = s.orderExecutor.GracefulCancel(ctx)
		bbgo.Sync(ctx, s)
	})

	s.OnEmergencyStop(func() {
		percentage := fixedpoint.NewFromFloat(1.0)
		if err := s.ClosePosition(context.Background(), percentage); err != nil {
			errMsg := "failed to close position"
			log.WithError(err).Errorf(errMsg)
			bbgo.Notify(errMsg)
		}

		if err := s.Suspend(); err != nil {
			errMsg := "failed to suspend strategy"
			log.WithError(err).Errorf(errMsg)
			bbgo.Notify(errMsg)
		}
	})

	// Setup indicators
	standardIndicatorSet := session.StandardIndicatorSet(s.Symbol)
	s.ema120d = standardIndicatorSet.EWMA(s.EMA120d)

	session.MarketDataStream.OnKLineClosed(func(kline types.KLine) {
		if s.Status != types.StrategyStatusRunning {
			return
		}

		if kline.Symbol != s.Symbol {
			return
		}

		closePrice := kline.GetClose()

		// Handle volume interval for entry
		if kline.Interval == s.VolumeInterval {
			// Check if we already have position
			if !s.Position.IsLong() && s.checkVolumeBreakout(kline) && s.checkEMAFilter(closePrice) {
				bbgo.Notify("Found %s volume breakout: volume %s, quote volume %s, price %s",
					s.Symbol,
					kline.Volume.String(),
					kline.QuoteVolume.String(),
					closePrice.String(),
					kline)

				orderForm := types.SubmitOrder{
					Symbol:           s.Symbol,
					Market:           s.Market,
					Side:             types.SideTypeBuy,
					Type:             types.OrderTypeMarket,
					Quantity:         s.Quantity,
					MarginSideEffect: s.MarginOrderSideEffect,
				}

				bbgo.Notify("Submitting %s market buy order with quantity %s",
					s.Symbol,
					s.Quantity.String(),
					orderForm)

				if _, err := s.orderExecutor.SubmitOrders(ctx, orderForm); err != nil {
					log.WithError(err).Error("submit order error")
				}
			}
		}

		// Handle engulfing interval for exit
		if kline.Interval == s.EngulfingInterval {
			// Track green klines for engulfing pattern
			if kline.GetClose().Compare(kline.GetOpen()) > 0 {
				s.lastGreenKline = &kline
			}

			// Check for engulfing exit pattern
			if s.Position.IsLong() && s.checkEngulfingExit(kline) {
				bbgo.Notify("Found %s engulfing exit pattern: red kline %s with volume %s > previous green volume %s",
					s.Symbol,
					closePrice.String(),
					kline.Volume.String(),
					s.lastGreenKline.Volume.String(),
					kline)

				if err := s.ClosePosition(ctx, fixedpoint.One); err != nil {
					log.WithError(err).Error("close position error")
				}
			}
		}
	})

	bbgo.OnShutdown(ctx, func(ctx context.Context, wg *sync.WaitGroup) {
		defer wg.Done()
		_ = s.orderExecutor.GracefulCancel(ctx)
	})

	return nil
}
