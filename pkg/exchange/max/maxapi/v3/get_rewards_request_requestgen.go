// Code generated by "requestgen -method GET -url v3/rewards -type GetRewardsRequest -responseType []Reward"; DO NOT EDIT.

package v3

import (
	"context"
	"encoding/json"
	"fmt"
	"net/url"
	"reflect"
	"regexp"
	"sync"
)

/*
 * RewardType sets
 */
func (g *GetRewardsRequest) RewardType(rewardType RewardType) *GetRewardsRequest {
	g.rewardType = &rewardType
	return g
}

/*
 * Currency sets
 */
func (g *GetRewardsRequest) Currency(currency string) *GetRewardsRequest {
	g.currency = &currency
	return g
}

/*
  - Timestamp sets timestamp: timestamp in millisecond.

responses records whose created time less than or equal to specified timestamp if order in desc, responses records whose created time is greater than or equal to timestamp if order in asc.
latest time as default.
*/
func (g *GetRewardsRequest) Timestamp(timestamp int64) *GetRewardsRequest {
	g.timestamp = &timestamp
	return g
}

/*
  - Order sets order default: "desc"

Enum: "asc" "desc"
order in created time.
*/
func (g *GetRewardsRequest) Order(order string) *GetRewardsRequest {
	g.order = &order
	return g
}

/*
 * Limit sets
 */
func (g *GetRewardsRequest) Limit(limit int64) *GetRewardsRequest {
	g.limit = &limit
	return g
}

// GetQueryParameters builds and checks the query parameters and returns url.Values
func (g *GetRewardsRequest) GetQueryParameters() (url.Values, error) {
	var params = map[string]interface{}{}

	query := url.Values{}
	for _k, _v := range params {
		if g.isVarSlice(_v) {
			g.iterateSlice(_v, func(it interface{}) {
				query.Add(_k+"[]", fmt.Sprintf("%v", it))
			})
		} else {
			query.Add(_k, fmt.Sprintf("%v", _v))
		}
	}

	return query, nil
}

// GetParameters builds and checks the parameters and return the result in a map object
func (g *GetRewardsRequest) GetParameters() (map[string]interface{}, error) {
	var params = map[string]interface{}{}
	// check rewardType field -> json key reward_type
	if g.rewardType != nil {
		rewardType := *g.rewardType

		// TEMPLATE check-required
		if len(rewardType) == 0 {
		}
		// END TEMPLATE check-required

		// assign parameter of rewardType
		params["reward_type"] = rewardType
	} else {
	}
	// check currency field -> json key currency
	if g.currency != nil {
		currency := *g.currency

		// TEMPLATE check-required
		if len(currency) == 0 {
		}
		// END TEMPLATE check-required

		// assign parameter of currency
		params["currency"] = currency
	} else {
	}
	// check timestamp field -> json key timestamp
	if g.timestamp != nil {
		timestamp := *g.timestamp

		// TEMPLATE check-required

		if timestamp == 0 {
		}
		// END TEMPLATE check-required

		// assign parameter of timestamp
		params["timestamp"] = timestamp
	} else {
	}
	// check order field -> json key order
	if g.order != nil {
		order := *g.order

		// TEMPLATE check-required
		if len(order) == 0 {
		}
		// END TEMPLATE check-required

		// assign parameter of order
		params["order"] = order
	} else {
	}
	// check limit field -> json key limit
	if g.limit != nil {
		limit := *g.limit

		// TEMPLATE check-required

		if limit == 0 {
		}
		// END TEMPLATE check-required

		// assign parameter of limit
		params["limit"] = limit
	} else {
	}

	return params, nil
}

// GetParametersQuery converts the parameters from GetParameters into the url.Values format
func (g *GetRewardsRequest) GetParametersQuery() (url.Values, error) {
	query := url.Values{}

	params, err := g.GetParameters()
	if err != nil {
		return query, err
	}

	for _k, _v := range params {
		if g.isVarSlice(_v) {
			g.iterateSlice(_v, func(it interface{}) {
				query.Add(_k+"[]", fmt.Sprintf("%v", it))
			})
		} else {
			query.Add(_k, fmt.Sprintf("%v", _v))
		}
	}

	return query, nil
}

// GetParametersJSON converts the parameters from GetParameters into the JSON format
func (g *GetRewardsRequest) GetParametersJSON() ([]byte, error) {
	params, err := g.GetParameters()
	if err != nil {
		return nil, err
	}

	return json.Marshal(params)
}

// GetSlugParameters builds and checks the slug parameters and return the result in a map object
func (g *GetRewardsRequest) GetSlugParameters() (map[string]interface{}, error) {
	var params = map[string]interface{}{}

	return params, nil
}

var GetRewardsRequestSlugReCache sync.Map

func (g *GetRewardsRequest) applySlugsToUrl(url string, slugs map[string]string) string {
	for _k, _v := range slugs {
		var needleRE *regexp.Regexp

		if cached, ok := GetRewardsRequestSlugReCache.Load(_k); ok {
			needleRE = cached.(*regexp.Regexp)
		} else {
			needleRE = regexp.MustCompile(":" + _k + "\\b")
			GetRewardsRequestSlugReCache.Store(_k, needleRE)
		}

		url = needleRE.ReplaceAllString(url, _v)
	}

	return url
}

func (g *GetRewardsRequest) iterateSlice(slice interface{}, _f func(it interface{})) {
	sliceValue := reflect.ValueOf(slice)
	for _i := 0; _i < sliceValue.Len(); _i++ {
		it := sliceValue.Index(_i).Interface()
		_f(it)
	}
}

func (g *GetRewardsRequest) isVarSlice(_v interface{}) bool {
	rt := reflect.TypeOf(_v)
	switch rt.Kind() {
	case reflect.Slice:
		return true
	}
	return false
}

func (g *GetRewardsRequest) GetSlugsMap() (map[string]string, error) {
	slugs := map[string]string{}
	params, err := g.GetSlugParameters()
	if err != nil {
		return slugs, nil
	}

	for _k, _v := range params {
		slugs[_k] = fmt.Sprintf("%v", _v)
	}

	return slugs, nil
}

// GetPath returns the request path of the API
func (g *GetRewardsRequest) GetPath() string {
	return "v3/rewards"
}

// Do generates the request object and send the request object to the API endpoint
func (g *GetRewardsRequest) Do(ctx context.Context) ([]Reward, error) {

	// empty params for GET operation
	var params interface{}
	query, err := g.GetParametersQuery()
	if err != nil {
		return nil, err
	}

	var apiURL string

	apiURL = g.GetPath()

	req, err := g.client.NewAuthenticatedRequest(ctx, "GET", apiURL, query, params)
	if err != nil {
		return nil, err
	}

	response, err := g.client.SendRequest(req)
	if err != nil {
		return nil, err
	}

	var apiResponse []Reward

	type responseUnmarshaler interface {
		Unmarshal(data []byte) error
	}

	if unmarshaler, ok := interface{}(&apiResponse).(responseUnmarshaler); ok {
		if err := unmarshaler.Unmarshal(response.Body); err != nil {
			return nil, err
		}
	} else {
		// The line below checks the content type, however, some API server might not send the correct content type header,
		// Hence, this is commented for backward compatibility
		// response.IsJSON()
		if err := response.DecodeJSON(&apiResponse); err != nil {
			return nil, err
		}
	}

	type responseValidator interface {
		Validate() error
	}

	if validator, ok := interface{}(&apiResponse).(responseValidator); ok {
		if err := validator.Validate(); err != nil {
			return nil, err
		}
	}
	return apiResponse, nil
}
